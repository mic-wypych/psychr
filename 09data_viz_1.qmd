---
title: "Data visualization part 1"
---

# Plotting data

Visualization is an indispensible part of data analysis. If done properly it allows us to understand a lot more about our analysis/data and to understand it much faster than by wading through text. It also looks really nice! And good news is that R is absolutely great for plotting! In this class we'll look at some basic R plotting functions first and then dive into the world of `ggplot2`, easily the best plotting package out there.

In this class we'll use the `midwest` dataset from `ggplot2` package. It stores a bunch of information about population of 5 midwestern states: Illinois, Indiana, Michigan, Ohio and Wisconsin. The data are at county level. Lets briefly look at our dataset for this class:

```{r}
library(tidyverse)
data("midwest")
glimpse(midwest)
```

## Some base R graphics

Before we move on to `ggplot2` lets look at some built-in base R graphics. The `graphics` and `stats` packages have some function for plotting already available.

-   The most generic is the `plot()` function. It allows you to create simple plots in R. The first arguments are usually the variables you want to map onto the axes:

    ```{r}
    plot(midwest$percadultpoverty, midwest$percollege)
    ```

-   `plot()` function has a bunch of arguments you can use to customize the plot. For example we can change the color and thickness of the points and add a title to the plot and axes:

    ```{r}
    plot(midwest$percadultpoverty, midwest$percollege, col = 2, lwd = 2,
         main = "Percent in college vs percent adults in poverty",
         xlab = "Percent adults in poverty",
         ylab = "percent in college")
    ```

    Unfortunately the `plot()` function does not have great documentation and finding some of the arguments can be quite difficult. Some of these arguments also have very unintuitive names (e.g. argument named `lty` specifies line type, good luck memorizing that!). Base R has additional functions for more specific plots. Namely, `lines()` will create a line plot, `points()` will create a scatterplot and `boxplot()` will create a boxplot. These functions have better documentation than the general `plot()` though I still don't consider it great. Lets see some of these in action. `lines()` and `points()` require that you first initialize the plots with the coordinates set to the variables of interest with the `plot()` function. You can specify what kind of plot (line plot, scatterplot etc) you want inside `plot()` by setting the `type` argument. E.g. setting it to `l` will create a line plot.

-   Lines: Lets say we want to make a line plot that will display the 10th, 50th and 90th quantile of percent of adults in poverty in all states. We'll also introduce the `axis()` function which gives you some control over how the x and y axis should look like. Here we need it because `lines()` does not like categorical values at x axis so we need to add the state names (we add them at the top) with `axis()`:

    ```{r}
    #get the quantiles
    library(dplyr)
    #calculate quantiles at of percadultpoverty for each state
    list_q <- tapply(midwest$percadultpoverty, midwest$state, quantile, c(.1,.5,.9))

    #convert the result into a dataframe with each column as one quantile and each row as one state
    df_q <- data.frame()
    df_q <- bind_rows(list_q[[1]], list_q[[2]], list_q[[3]], list_q[[4]], list_q[[5]])
    colnames(df_q) <- c("q_10", "q_50", "q_90")

    #plot them
    plot(1:5, df_q$q_10, ylim = c(0,20), type = "l", col = 2, lwd = 2, lty = 2)
    lines(1:5, df_q$q_50, col = 4, lwd = 2, lty = 1)
    lines(1:5, df_q$q_90, col = 2, lwd = 2, lty = 2)
    axis(side = 3, at = 1:5, labels = unique(midwest$state))
    ```

    One important thing here: notice how each element is added to the plot on a new line. These functions are not chained together in any way and we are not saving any intermediate objects. This is pretty unusual in R (although perfectly normal in other programming languages). It's just how base R plotting works.

-   Points: We can recreate the plot that we made with the generic `plot()` function but using `points()`:

    ```{r}
    plot(midwest$percadultpoverty, midwest$percollege)
    points(midwest$percadultpoverty, midwest$percollege, col = 2, lwd = 2, 
         main = "Percent in college vs percent adults in poverty",
         xlab = "Percent adults in poverty",
         ylab = "percent in college")

    ```

-   Boxplots are useful for showing differences in distributions of some continuous variable between levels of some factor. For example lets say we want to

    ```{r}
    boxplot(midwest$percadultpoverty ~ midwest$state)
    ```

There are also built-in functions for plotting distributions: `hist()` for histograms, `plot(density())` for density functions and `plot.ecdf()` for cumulative distribution plots. Lets look at all 3 plots for percent of population in college:

```{r}
hist(midwest$percollege)
```

```{r}
plot(density(midwest$percollege))
```

```{r}
plot.ecdf(midwest$percollege)
```

One problem with base R plots is that they are not intuitive. Lots of arguments have weird names and doing some things is really not so easy. Making more complicated plots (e.g. adding text annotations on the plot) is also generally hard to do. That's why we'll focus on `ggplot2` which is much more intuitive and versatile.

## Enter ggplot2

`ggplot2` is a package in th `tidyverse` designed for making data visualizations. One of the great things about it is that it breaks down each plot into a number of layers that can be changed (more or less) independently. This idea is encapsulated in what is called the grammar of graphics.

## Grammar of graphics

The name comes from a book by Leland Wilkinson under the same title. Basically making a plot with the grammar of graphics is like making a building with lego blocks with different colors. You can mix the colors of the blocks to get exactly the building you want. Similalry in `ggplot2` you can use different layers to make the plot that you want (e.g. mix different datasets or add a line to a scatterplot). Ok, but what are those layers? In `ggplot2` there are following layers:

-   Data: the datasets (usually data frames) you want to plot

-   Aesthetics: mapping between data and the plot, e.g. what is to be mapped to x and y axis

-   Geometry: shapes used to represent data

-   Statistics: any statistics like means or confidence intervals that you want to add

-   Coordinates: coordinates of the plot (axes limits, cartesian vs polar coordinates etc.)

-   Facets: this layer is used for making subplots (e.g. separate plot for each level of a categorical variable)

-   Theme: All non-data stuff like fonts, titles

You always start the plot with `ggplot()` function. All the lego blocks that you want to add are chained together with `+`. Lets see what happens when we pass the first layer, data, to our plot:

```{r}
midwest %>%
  ggplot()
```

Hmm, we get en empty plot. Why is that? Well, all we supplied so far is the data we want to plot but we did not include any additional information so R doesn't know yet what exactly should be displayed on the plot. We need to add the next layer: aesthetics.

## Aesthetics

Aesthetics map what variables should be displayed on the plot in what way. In this layer you declare e.g. what should be on the x and y axis. The basic aesthetics (the list is not exhaustive) are:

-   x axis

-   y axis

-   colour: colour of points and lines (that includes borders of e.g. rectangles)

-   fill: colour of filling

-   alpha: transparency. 0 means completely transparent, 1 means not transparency

-   size: point size

-   linewidth: width of lines

-   linetype: type of line (e.g. dashed)

-   shape: shape of points (circles, rectangles, etc.)

-   labels: text

Aesthetics are declared within `aes()`. It can be declared within `ggplot()` function, separately or inside geoms (more on those in a second). Lets see what happens when we add aesthetics to our plot:

```{r}
midwest %>%
  ggplot() +
  aes(x = percadultpoverty, y = percollege)
```

Now we got our axes! Notice there is no data on the plot though. That's because so far we have declared which dataset to plot and which variables to map onto axes but we did not specify how to represent the data. This is declared in the next layer: geometry.

## Geometries

After providing a dataset and aesthetics we have the variables and their mapping to axes on the plot. However, we still don't have any shapes to actually represent the data. Do we want a scatter plot? Or maybe a bar plot? Or a line plot? The shapes used to represent the data are defined in the geometry layer. Generally all geometries start with `geom_` so for example `geom_point()` will make a scatter plot while `geom_bar()` will make a bar plot.

Geometries differ in what aesthetics they accept. You can look up what these are by looking up help for a given geometry. Each geometry has all the aesthetics it accepts in its documentation. They also differ in what kinds of variables they expect (any combination of categorical vs continuous variables).

Lets expand the initial plot with `geom_point()` to make a scatterplot!

```{r}
midwest %>%
  ggplot() +
  aes(x = percadultpoverty, y = percollege) +
  geom_point()
```

We got a plot very similar to the one we made with base R! We can customize it further if we want to. Lets say we want to represent each state with a different color. We just need to add a color aesthetic. R will add a legend automatically:

```{r}
midwest %>%
  ggplot() +
  aes(x = percadultpoverty, y = percollege, color = state) +
  geom_point()
```

There is one more thing about geometries and aesthetics. Remember you can declare aesthetics in different places? You can set global aesthetics inside the `ggplot()` function. If you do so these aesthetics will be used by default by all geometries in that plot. You can also set aesthetics inside a given geometry (in fact you can even set a different dataset for a given geometry; this is what we meant by independence of layers) but then they will be used only for this particular geometry and won't be inherited by other ones.

Compare the to plots below. They produce the same result:

```{r}
midwest %>%
  ggplot(aes(x = percadultpoverty, y = percollege)) +
  geom_point()
```

And the second plot:

```{r}
midwest %>%
  ggplot() +
  geom_point(aes(x = percadultpoverty, y = percollege))
```

Some common geometries you can encounter are as follows:

-   `geom_histogram()` and `geom_density()` for displaying distributions of continuous variables

-   `geom_bar()` for displaying counts of categorical variables (you can change counts to other summary statistic but more on that later)

-   `geom_col()` for displaying differences in some continuous variable between levels of a factor

-   `geom_point()`: your good old scatterplot

-   `geom_boxplot()`

-   `geom_violin()` a bit like boxplot but displays a distribution of a continuous variable for each level of a factor

-   `geom_smooth()` for displaying lines of best fit (e.g. from a linear model)

You can check them out if you want to to see how they look like.

Lets look at 2 thing in a bit more details with regard to geometries. First, lets look at combining geoms. We can add a line of best fit to our scatterplot if we want to by adding an additional geometry. `geom_smooth()` will use a GAM or LOESS by default (depending on how many unique values x variable has) but we can set it to a linear model by adding `method = "lm"`. A linear model probably won't do well here but it's just for demonstration:

```{r}
midwest %>%
  ggplot(aes(x = percadultpoverty, y = percollege)) +
  geom_point() +
  geom_smooth(method  ="lm")
```

See? Just like building with lego blocks.

Last thing before we move on: a few words on `geom_bar()` and `geom_col()`. They often get mixed up at the beginning because they both show bar plots. `geom_bar()` takes a single aesthetic and is generally used to display counts of some factor variable. For example if we wanted to see how many counties are there in each state we could use `geom_bar()` (later we'll see how to display e.g. means of variables across levels of a factor):

```{r}
midwest %>%
  ggplot(aes(x=state)) +
  geom_bar()
```

`geom_col()` takes at least 2 aesthetics: x and y. It needs one categorical and one continuous variable. By default it is going to sum all values in a given category. e.g. lets look at the sum of area of all counties in each of the states:

```{r}
midwest %>%
  ggplot(aes(x=state, y = area)) +
  geom_col()
```

What if we wanted to look at the average county area in each state? We can e.g. first summarise the dataset and then pipe it to plot:

```{r}
midwest %>%
  summarise(mean_area = mean(area), .by = state) %>%
  ggplot(aes(x = state, y = mean_area)) +
  geom_col()
```

Since `ggplot2` is part of `tidyverse` it's really easy to pipe a set of dplyr functions into a plot in a single call!

## Attributes

There are situations in which you don't want to set some feature to be represented by a given variable but to set them to a fixed value for the entire plot/geometry. For example you might want to set the color or size of all points in a scatter plot. That's when you set attributes. They are declared inside geometries but outside of aesthetics. Lets say we want to take our scatterplot and change the transparency and color of the points. We can do it by defining them inside geometry. The names for the arguments are the same as for aesthetics. Just remember to use them outside of `aes()`!

```{r}
midwest %>%
  ggplot() +
  geom_point(aes(x = percadultpoverty, y = percollege), color = "red", alpha = .3)
```

By the way, you can define colors either with hex values as RGB but you can also use one of the built-in colors in R. You can check all the names of those built-in colors with `colors()` function. Another neat thing is that in newer version of RStudio you can see the preview of the colors when you type them in a script.

## Scales

One more thing are functions for working with scales: they allow you to have more control over how each scale is represented (e.g. what the breaks and values are, should the scale be transformed). For example notice that R automatically chose some limits for the scales and displayed breaks (the values on the axes). You can have more control over that with the `scale_` family of functions. It's a family of functions because you need to declare: 1) which aesthetic you want to change and 2) what kind of scale you are working with (continuous, discrete or binned). So for example `scale_x_continuous()` allows you to customize a continuous x axis. The basic things that you can change inside the `scale_` function are: breaks, labels, limits and the expand argument (the last one controls additional space - notice that e.g. on the x axis there is a little space on the left of 0 and there is similarly a little space to the right of the point with the highest percadultpoverty value).

Lets say now we want to work a little with our scales. Lets change the breaks to be every 5%, change the labels to be actually in percentage format (there is a very neat function in `scales` package called `label_percent()` that does that. We just need to set scale argument in it to 1 because in our dataset e.g. 10% is represented as 10 and not 0.1):

```{r}
midwest %>%
  ggplot() +
  geom_point(aes(x = percadultpoverty, y = percollege), color = "red", alpha = .3) + scale_x_continuous(breaks = seq(0,40,5),labels = scales::label_percent(scale = 1)) +
  scale_y_continuous(breaks = seq(0,50,5),labels = scales::label_percent(scale = 1))
```

A cautionary tale about using limits in `scale_` functions: These limits work by filtering the data to be plotted. This can be a serious problem because you basically lose data when plotting and only get a warning about it. This can be especially problematic if you are trying to display bars or ranges because if e.g. one side of an interval falls out of the limits, the entire range will not be displayed. Lets see what happens if we set limits on one of our axes:

```{r}
midwest %>%
  ggplot() +
  geom_point(aes(x = percadultpoverty, y = percollege), color = "red", alpha = .3) + scale_x_continuous(breaks = seq(0,25,5),labels = scales::label_percent(scale = 1), limits = c(0, 25)) +
  scale_y_continuous(breaks = seq(0,50,5),labels = scales::label_percent(scale = 1))
```

Notice the warning about removed data. This is especially problematic in bar plots because by default they start from 0 (which can be a good thing because it reduces misinterpretation of visual differences between bars but can be undesired e.g. if displaying results of a 1-5 Likert scale which doesn't have a 0). Another problematic situation is when plotting some summaries e.g. means and limiting axes. Limits will work before calculating the summaries so you might get nonsensical plots because of this like below where we try to plot mean `percadultpoverty` by each state and limit the y axis to 10:

```{r}
midwest %>%
  ggplot(aes(x = state, y = percadultpoverty)) +
  geom_bar(stat = "summary", fun = mean) +
  scale_y_continuous(limits = c(0,10))
```

The warning now says that 220 rows were removed! What's even weirded we still got our plot but the means were calculated based on trimmed variable.

## Colors

Scale functions also allow you to control the color and fill aesthetics. You can change which color palette you want to use

-   Discuss brewer and viridis packages

What to be mindful of when setting color palettes:

-   how people perceive color

-   what information you want to represent (is there some order to the variable, is it divergent etc.)

## Positions

-   What are position adjustments

-   Basic adjustments
