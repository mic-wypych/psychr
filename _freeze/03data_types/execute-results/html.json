{
  "hash": "63136f01d55f2e672a11570a0589ae62",
  "result": {
    "markdown": "---\ntitle: \"Types of data\"\nauthor: \"Michal Wypych\"\n---\n\n\nSo far we have worked only with single values. However, usually you want to work with whole sets of values like variables or whole datasets. There is a number of types of data you can encounter in R. A fairly easy way to orient yourself in the different types of data is:\n\n1.  how many dimensions does a given type have\n2.  What kinds of values can it store?\n\n## Vectors\n\nThe most basic type of data is a vector. Vectors can store any number of values of the same type in 1 dimension. You can create a vector using `c()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_very_first_vector <- c(1,2,3)\nmy_very_first_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nVectors are **indexed**: they have a first, second value etc. This means that you can access part of a vector -subset them. Subsetting is accomplished with `[]`. You can also subset a range of values from a vector wirh `[:]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector <- c(1,2,3,4,5,6,7,8,9,10)\nlong_vector[3:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n:::\n\n\nIf you try to put different types of values into one vector R will convert the types to a matching one. This is especially important when due to some mistake/error a single value of a different type gets lost in some other variable. Just a single value will trigger the whole variable to be converted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, TRUE, 'some text')\nmy_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"         \"TRUE\"      \"some text\"\n```\n:::\n\n```{.r .cell-code}\nclass(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nYou can make pretty much the same operations on vectors as on single values. One of the great features of R is that by default it will make operations element wise - if you try to add two vectors together then the first element from vector 1 will be added to first element of vector 2 and so on (the fancy name for this is vectorization).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1,2,3,4,5)\nnumbers2 <- c(6,7,8,9,10)\nnumbers + numbers2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7  9 11 13 15\n```\n:::\n:::\n\n\nIf the vectors have different lengths then R will start to recycle values from the shorter vectors. But it will output a warning if the length of one vector is not a multiple of the other vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshort_v <- c(1,2,3)\nlong_v <- c(1,2,3,4,5)\nshort_v + long_v\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in short_v + long_v: długość dłuszego obiektu nie jest wielokrotnością\ndługości krótszego obiektu\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 5 7\n```\n:::\n:::\n\n\n## Factors\n\nFactors are much like vectors except that they are used for storing categorical values - they have levels. You can store variables such as country or experimental condition of participants in a factor. You can create a factor by calling `factor()` and passing it a vector as an argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c('a', 'b', 'a', 'b')\nmy_factor <- factor(my_vector)\nmy_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] a b a b\nLevels: a b\n```\n:::\n:::\n\n\nFactors can also have ordered levels. You can make an ordered factor by setting `ordered = T` argument when creating a factor. Notice how the output looks different now: it includes information on the order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T)\nordered_fac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] low  high high low  low \nLevels: high < low\n```\n:::\n:::\n\n\nYou can also manually set the levels of a factor. You can do it when creating the factor. Notice that for ordered factor the order in which you pass the levels will determine the order of levels in the factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T, levels = c('low', 'high', 'medium'))\nordered_fac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] low  high high low  low \nLevels: low < high < medium\n```\n:::\n:::\n\n\n## Matrices\n\nMatrices are a bit like vectors but they have two dimensions. They have rows and columns but treat them in the same way. Because of this they can store only one type of values (much like vectors). You can create a matrix from scratch with the `matrix()` function. This function takes a vectors of values as its input (these are the values we will fill our matrix with) and additional information on how the matrix has to look - how many columns and rows it should have and whether to fill the matrix with values by rows or columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbered_vector <- c(1,2,3,4,5,6,7,8,9)\nmy_matrix <- matrix(numbered_vector, nrow = 3, ncol = 3)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n\nYou can also create a matrix by 'glueing' vectors together. You can bind them either as rows (`rbind()` function) or by columns (`cbind()` function). Notice that the names of the vectors will be used either as names of rows or columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec1 <- c(1,2,3)\nvec2 <- c(4,5,6)\ncbind(vec1, vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     vec1 vec2\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n\nSince we have two dimensions subsetting matrices can work both on rows and columns. The general idea is still the same but we have to specify whether we are subsetting rows or columns. Rows always come first, columns second separated by a comma like this `matrix[rows,columns]`. You can select ranges of rows or columns just like in a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nIf you want to select all rows or columns you can leave the space blank. Remember to keep the comma though!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7 8 9\n```\n:::\n:::\n\n\n## Data frames\n\nIn a day to day analysis you will likely work with data frames most of the time. A data frame is like a matrix in that it has rows and columns but can store different types of values in each column (so that e.g. you can have some variables that are numeric and others that are text). A different way of thinking about data frames is as a list of vectors of the same length with each vector representing a different variable. Each row represents a different observation (e.g. participant).\n\nYou can create a data frame with `data.frame()` function passing all the variables as arguments. Lets create 3 vectors: author, title and year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauthor <- c('Allport', 'Heider', 'Lewin', 'Allport', 'Heider')\ntitle <- c('Nature of Prejudice', 'Psychology of interpersonal relations',\n           'Principles of Topological Psychology', 'Psychology of Rumor', 'The life of a psychologist: An autobiography')\nyear <- c(1954, 1958, 1936, 1947, 1983)\n\npsych_books <- data.frame(author, title, year)\npsych_books\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                        title year\n1 Allport                          Nature of Prejudice 1954\n2  Heider        Psychology of interpersonal relations 1958\n3   Lewin         Principles of Topological Psychology 1936\n4 Allport                          Psychology of Rumor 1947\n5  Heider The life of a psychologist: An autobiography 1983\n```\n:::\n:::\n\n\nSubsetting data frames works the same way as matrices. You can subset both on rows and columns. An important thing to remember (and one of the reasons a lot of people switch to tibbles which are kind of data frames+. We'll get to tibbles some time in the future) is that if you subset a single column the result will be a vector and not a dataframe. This sometimes is annoying if you are designing something that is supposed to work on data frames specifically.\n\nThere is one additional way of subsetting a data frame. Subsetting variables based on their position is tiresome because we rarely remember the order of all the columns (especially as our data frames get bigger). You can select a single variable using `$`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books$author\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Allport\" \"Heider\"  \"Lewin\"   \"Allport\" \"Heider\" \n```\n:::\n:::\n\n\nUsing the `$` operator reflects a way of thinking about datasets that is pretty common: data frames are ordered collections of variables and each variable has its name. You can also use `$` to create new variables. Just assign a vector of values to a new name in your dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books$discipline <- c('intergroup relations', 'social psychology',\n                            'general psychology', 'social psychology',\n                            'biography')\npsych_books\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                        title year\n1 Allport                          Nature of Prejudice 1954\n2  Heider        Psychology of interpersonal relations 1958\n3   Lewin         Principles of Topological Psychology 1936\n4 Allport                          Psychology of Rumor 1947\n5  Heider The life of a psychologist: An autobiography 1983\n            discipline\n1 intergroup relations\n2    social psychology\n3   general psychology\n4    social psychology\n5            biography\n```\n:::\n:::\n\n\nRemember how we talked about element-wise operations on vectors? You can leverage it to easily create new variables that are results of operations on other variables. Thanks to this you can add a whole new variable that is a result of a mathematical operation in just one line (imagine adding a variable that is a sum of all points from a quiz for each student). Here's an example if we wanted to calculate how many years ago each book from our data frame was published:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books$book_age <- 2022 - psych_books$year\npsych_books\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                        title year\n1 Allport                          Nature of Prejudice 1954\n2  Heider        Psychology of interpersonal relations 1958\n3   Lewin         Principles of Topological Psychology 1936\n4 Allport                          Psychology of Rumor 1947\n5  Heider The life of a psychologist: An autobiography 1983\n            discipline book_age\n1 intergroup relations       68\n2    social psychology       64\n3   general psychology       86\n4    social psychology       75\n5            biography       39\n```\n:::\n:::\n\n\n## Lists\n\nLists are the final type of basic data in R we will discuss here. They are the most versatile ones - they can store anything inside of them: single values, vectors, matrices, dataframes or even other lists! One important feature of lists is that they are ordered: you can access their elements by position. So you can think of lists as collections of objects but there aren't really limits to what these objects are (in fact dataframes are very specific lists: they are collections of variables that have the same length and form a nice rectangular table). Lists are created with `list()`. Lets create a list of the plants in a house along with a value storing information on how many days ago did we last water them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_objects <- list(\n  plants = c('Calathea', 'Chamedora', 'Pilea', 'Philodendron'),\n  days_since_watering = 5\n)\nlist_of_objects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$plants\n[1] \"Calathea\"     \"Chamedora\"    \"Pilea\"        \"Philodendron\"\n\n$days_since_watering\n[1] 5\n```\n:::\n:::\n\n\nYou might encounter lists if you need to store a number of different things together. E.g. results of many statistical analyses are stored in lists. In fact as you dive deeper into R you will start to encounter more and more lists because they are very versatile.\n\nYou can access objects stored in lists in a few ways. You can use the `[]` you used for all other types of data. An important feature of this type of subsetting is that the result will always be a list (even if it has only 1 element). The other option is to use double square brackets `[[]]`. This will extract the object inside a list so the result won't be a list (you can think of it as 'getting deeper' into the list to extract the exact element you want).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_objects[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$plants\n[1] \"Calathea\"     \"Chamedora\"    \"Pilea\"        \"Philodendron\"\n```\n:::\n\n```{.r .cell-code}\nlist_of_objects[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Calathea\"     \"Chamedora\"    \"Pilea\"        \"Philodendron\"\n```\n:::\n:::\n\n\nIf the elements in your list are named you can also use `$` to extract them.\\\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_objects$days_since_watering\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}