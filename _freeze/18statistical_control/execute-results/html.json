{
  "hash": "bc3bbca78125f979c3ff12f3fd3729c4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Statistical control\"\nauthor: \"Michał Wypych\"\n---\n\n\nSo far we have been working with only 1 independent variable at a time. It's time to move on to multiple predictors.\n\n## What is statistical control?\n\nWhen we include more than one predictor we often say that we are controlling for a number of variables in the model. This innocent-sounding term can actually sometimes cause quite a head ache to wrap your head around it. What does it mean to control for a variable?\\\nOne seemingly simple answer is that controlling means estimating the effect of one variable while holding the other variable constant. We'll look at what exactly that means in this class. As a first approximation lets make a simple graphical interpretation of statistical control. We will denote `x` as the min independent variable, `u` as the control variable and `y` as the dependent variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nN <- 1e3\nx <- rnorm(N)\nu <- rbinom(N,1,.5)\ny <- rnorm(N, 4 + .7*x + 1*u, 1.3)\n\ndf <- data.frame(x, u, y)\n\n\ndf$pred <- lm(y ~ x + u, df) |>\n  predict() # get predicted values from the model\n\n#plot predictions and raw data \ndf %>% \n  ggplot(aes(x = x, y = pred, color = factor(u), group = factor(u))) +\n  geom_point(aes(x = x, y = y, color = factor(u)),alpha = .3) +\n  geom_line() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](18statistical_control_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nYou can see the effects plotted. The lines show the effects of `x` on `y`. Each level of `u` has its own line. Notice that both lines have the same slope - regardless of the level of `u` the effect of `x` on `y` is the same. This is exactly what statistical control means in this case. The effect of `u` can be understood as the distance between both lines. Again notice that it is the same across the entire range of the lines. No matte what value of `x` we take the effect of `u` is the same. Likewise for the effect of `x`.\n\nWe can try a similar thing with 2 continuous predictors but this is going to be more difficult to plot as we are still working in 2 dimensions. One trick we can use is to plot the effect of `x` on `y` for various levels of `u` (lets say quantiles).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 1e3\nx <- rnorm(N)\nu <- rnorm(N,1 + .3*x, 1)\ny <- rnorm(N, 4 + .7*x + 1*u, 1.3)\n\ndf <- data.frame(x, u, y)\n\n\nmodel_2<- lm(y ~ x + u, df)  # get predicted values from the model\n\npred.data = expand.grid(x = seq(min(df$x), max(df$x), length=20),\n                        u = quantile(df$y))\npred.data$y = predict(model_2, newdata=pred.data)\n\nggplot(pred.data, aes(x, y, colour=factor(u))) +\n  geom_line() +\n  labs(colour=\"U Quantiles\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](18statistical_control_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nYou can again see that the slope for `x` is the same at each quantile of `u`. This means that in our model for any value of `u` the effect of `x` on `y` is the same. If we reversed it we would see the same thing for `u`.\n\n## To control or not to control?\n\nWhy do we add control variables into the model? We can think about two basic reasons: to make better predictions or to adjust the effect of one variable to account for confounding. The first case is tied to prediction problems - adding additional information should make our predictions better right? The second case has a lot to do with the \"correct model specification\" assumption for linear models. If there is an important variable that should be included in the model but we did not do it then our effect is going to be biased. Such variables are called confounders. However they can take different forms depending on exactly how the relations between variables look like. A really good paper on this topic is [here](https://compass.onlinelibrary.wiley.com/doi/10.1111/spc3.12948).\n\nI think one of the clearest ways to see how different confounders affect the model is to simulate them. This way we know exactly what the correct answers are and how including the confounder affects the model. The basic types of confounds are: fork, mediator, collider and descendant. In each of the simulated situations below we will work with 3 variables `x` is our independent variable, `y` is our dependent variable and `u` is the confounder.\n\n### Fork\n\nA fork is a variable that affects both `x` and `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 1e4\nu <- rnorm(N, 5, 1.3)\nx <- rnorm(N, 3 + .5*u, 1)\ny <- rnorm(N, 2 + .4*x + .3*u, 1.3)\n\nlm(y ~ x) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.8660 -0.9032 -0.0166  0.9135  4.9062 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  2.46430    0.06334   38.91   <2e-16 ***\nx            0.58692    0.01131   51.89   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.338 on 9998 degrees of freedom\nMultiple R-squared:  0.2122,\tAdjusted R-squared:  0.2121 \nF-statistic:  2693 on 1 and 9998 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nlm(y ~ x + u) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + u)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.8579 -0.8897 -0.0075  0.8853  4.4536 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.99459    0.06482   30.77   <2e-16 ***\nx            0.41726    0.01317   31.69   <2e-16 ***\nu            0.28073    0.01194   23.50   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.302 on 9997 degrees of freedom\nMultiple R-squared:  0.2535,\tAdjusted R-squared:  0.2533 \nF-statistic:  1697 on 2 and 9997 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\nYou can see that not including `u` in the model gives us the wrong answer. This is the confounding that people most commonly have in mind when they are controlling for things in their models.\n\n### mediator\n\nA mediator is a variable that is affected by `x` and affects `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(N, 3 , 1)\nu <- rnorm(N, 5 + .5*x, 1.3)\ny <- rnorm(N, 2 + .4*x + .3*u, 1.3)\n\nlm(y ~ x) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.9506 -0.8886  0.0040  0.9069  5.1735 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  3.46906    0.04218   82.23   <2e-16 ***\nx            0.55885    0.01343   41.62   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.348 on 9998 degrees of freedom\nMultiple R-squared:  0.1476,\tAdjusted R-squared:  0.1476 \nF-statistic:  1732 on 1 and 9998 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nlm(y ~ x + u) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + u)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.9116 -0.8633  0.0153  0.8683  4.9526 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 1.891485   0.063771   29.66   <2e-16 ***\nx           0.405484   0.013671   29.66   <2e-16 ***\nu           0.312772   0.009816   31.86   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.284 on 9997 degrees of freedom\nMultiple R-squared:  0.2262,\tAdjusted R-squared:  0.2261 \nF-statistic:  1461 on 2 and 9997 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\nAgain including a mediator gives us the wrong answer!\n\nGiven how popular mediation analysis is in psychology you might be a bit worried about this result and rightly so! [Here's a great paper that goes into this topic in details](https://journals.sagepub.com/doi/full/10.1177/25152459221095827).\n\nThis issue also pops up in what is called the port-treatment bias. Basically it boils down to controlling for variables that are downstream of your treatment (be it in experiment or in an observational study). For example if you ran a randomized experiment and measured a bunch of things should you control for something measured after the experimental manipulation? If you are interested in the effect of the experiment then the anwser is no. There are even much more subtle ways in which post treatment bias can creep in - e.g. excluding participants who failed an attention check after the manipulation is effectively introducing post treatment bias. After all you are holding constant the value of a variable \"passed attention check\". You can read about it [here](https://bpb-us-e1.wpmucdn.com/sites.dartmouth.edu/dist/5/2293/files/2021/03/post-treatment-bias.pdf).\n\n### Collider\n\nA collider is a variable that is affected by both `x` and `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(N, 3 , 1)\ny <- rnorm(N, 2 + .4*x , 1.3)\nu <- rnorm(N, 5 + .5*x + .3*y, 1.3)\n\n\nlm(y ~ x) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.8799 -0.8729 -0.0041  0.8741  5.1638 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.99591    0.04048   49.31   <2e-16 ***\nx            0.40620    0.01275   31.85   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.287 on 9998 degrees of freedom\nMultiple R-squared:  0.09213,\tAdjusted R-squared:  0.09204 \nF-statistic:  1015 on 1 and 9998 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nlm(y ~ x + u) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + u)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4.5124 -0.8549  0.0133  0.8290  4.7999 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 0.549941   0.063700   8.633   <2e-16 ***\nx           0.238562   0.013582  17.564   <2e-16 ***\nu           0.261898   0.009135  28.670   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.237 on 9997 degrees of freedom\nMultiple R-squared:  0.1611,\tAdjusted R-squared:  0.1609 \nF-statistic: 959.9 on 2 and 9997 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\nThis one is particularly bad because here including `u` gives us the wrong answer! It is worth spending a little more time on colliders because they are particularly insidious and can creep in where you expect them the least.\n\n-   **disucss selection bias as a case of collider bias?**\n\n    Collider bias ca\n\n### Descendant\n\nA descendant is a variable that is affected by the confounder. We will denote the descendant as `z`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- rnorm(N, 5, 1.3)\nz <- rnorm(N, 1 + .8*u, .5)\nx <- rnorm(N, 3 + .5*u, 1)\ny <- rnorm(N, 2 + .4*x + .3*u, 1.3)\n\nlm(y ~ x) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.3866 -0.9208  0.0103  0.9187  5.0053 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   2.4844     0.0631   39.37   <2e-16 ***\nx             0.5848     0.0112   52.21   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.339 on 9998 degrees of freedom\nMultiple R-squared:  0.2143,\tAdjusted R-squared:  0.2142 \nF-statistic:  2726 on 1 and 9998 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nlm(y ~ x + z) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + z)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.0037 -0.9035  0.0049  0.9098  4.9554 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.80563    0.06843   26.39   <2e-16 ***\nx            0.43986    0.01266   34.75   <2e-16 ***\nz            0.29528    0.01302   22.68   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.306 on 9997 degrees of freedom\nMultiple R-squared:  0.2527,\tAdjusted R-squared:  0.2525 \nF-statistic:  1690 on 2 and 9997 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\nlm(y ~ x + u) |> summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ x + u)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.0641 -0.8847  0.0078  0.8854  4.8762 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.96637    0.06418   30.64   <2e-16 ***\nx            0.39587    0.01302   30.39   <2e-16 ***\nu            0.31152    0.01191   26.15   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.296 on 9997 degrees of freedom\nMultiple R-squared:  0.2646,\tAdjusted R-squared:  0.2644 \nF-statistic:  1798 on 2 and 9997 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\nThe answer when controlling for the descendant is not perfect but it is much better than including just `x`. One way to think about it is that in some analyses it can serve as a proxy variable if the actual confound is difficult to measure.\n\n## Interpreting multiple regression\n\nLets say we have already ran a model with multiple predictors in it. How should we interpret the results? I have already told you that in such a case the effect of your main variable should be understood as \"the effect of x while holding all other covariates constant\". How should we understand this in practice though? You should be aware that introducing a covariate changes the interpretation of the coefficient for the main variable of interest. This is especially stark in some situations where the variables you put in the model are conceptually linked to each other. Here's an example I've seen somewhere (unfortunately can't find where to give you a link).\\\nImagine you are predicting household income using family size and number of adults in the household. In such a model what does it mean to have an effect of family size while holding number of adults constant? Well, it's the number of kids in the house! So including number of adults into the model completely changes the meaning of the family size variable. What then is the effect of number of adults while holding family size constant? This one then is pretty weird and much harder to interpret. Maybe it's the effect of a kid becoming an adult?\n\nHere's another example from psychology: imagine you are predicting voting intentions using a set of\n\n**describe this example**\n\nThis shows that throwing additional variables into the model can not only estimate wrong effects but render them pretty much uninterpetable.\n\nApart from changes in interpretation of the effect of the main variable you might be interested in interpretation of the effects of the covariates themselves. Imagine a model in which you predict verbal aggression with Social Dominance Orientation (a social darwinist worldview that the world is inherently hierarchical and groups fight each other for status and resources). You think that both of these are different between men and women so you control for gender in the model. What does the effect of gender mean here? You might be tempted to interpret it just as \"the difference between men and women in verbal aggression while holding SDO constant\". But what does that really mean? Remember that we think that both SDO and verbal aggression are affected by gender and that SDO affects verbal aggression. This means that when we shift focus from SDO to gender SDO becomes a mediator! So the effect we get from our regression is the direct effect of gender and not the total effect. Casually interpreting the effects of covariates from a model is often called [Table 2 fallacy](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3626058/). Always think carefully what a given effect represents because it is rarely obvious and simple. [Here's another great paper on this topic](https://journals.sagepub.com/doi/full/10.1177/25152459221095823).\n\n## So what do I do?\n\nFrom all of the above you might get the impression that working in the multivariate world is dangerous and you are pretty much destined to fall into one of the many traps of statistical control. There is indeed a lot of things that can go wrong very easily. So what should you do? The answer is always: think! Think carefully. This way you can at least prepare for potential problems and avoid misinterpretation. A humble and right result is infinitely better than a bombastic and wrong one. The software will (almost) always spit out some result. It is up to you to decide what it means and whether it makes any sense at all. You have to be able to say what the model can and what it can't tell you. Being able to critique models (not in the sense of saying how they are wrong but carefully studying their limitations) is a skill that takes time to develop but with practice you can get really good at it and it will profit in the future.\n",
    "supporting": [
      "18statistical_control_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}