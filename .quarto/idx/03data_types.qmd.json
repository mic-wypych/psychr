{"title":"Types of data","markdown":{"yaml":{"title":"Types of data","author":"Michal Wypych"},"headingText":"Vectors","containsRefs":false,"markdown":"\n\nSo far we have worked only with single values or objects storing only one value. However, usually you want to work with whole sets of values like variables or whole datasets. There is a number of types of data you can encounter in R which allow you to do that. A fairly easy way to orient yourself in the different types of data is:\n\n1.  how many dimensions does a given type have: you can think about it in terms of how many ways can you traverse a given object: if you can only move left or right then it has only one dimension. If you can move left or right and up or down then you have 2 dimensions.\n2.  What kinds of values can it store? Some types can store values of only 1 type while others can store multiple types of values a the same time.\n\n\nThe most basic type of data is a vector. Vectors can store any number of values of the same type in 1 dimension. You can create a vector using `c()` function.\n\n```{r}\nmy_very_first_vector <- c(1,2,3)\nmy_very_first_vector\n```\n\nVectors are **indexed**: they have a first, second value etc. This means that you can access part of a vector -subset them. Subsetting is accomplished with `[]`. You can also subset a range of values from a vector wirh `[:]`:\n\n```{r}\nlong_vector <- c(1,2,3,4,5,6,7,8,9,10)\nlong_vector[3:5]\n```\n\nIf you try to put different types of values into one vector R will convert the types to a matching one. This is especially important when due to some mistake/error a single value of a different type gets lost in some other variable. Just a single value will trigger the whole variable to be converted!\n\n```{r}\nmy_vector <- c(1, TRUE, 'some text')\nmy_vector\nclass(my_vector)\n```\n\nYou can get a brief summary of a given vector with `summary()`. It will give slightly different information depending on what type of values is stored in a given vector:\n\n```{r}\nsummary(long_vector)\nsummary(my_vector)\n```\n\nYou can make pretty much the same operations on vectors as on single values. One of the great features of R is that by default it will make operations element wise - if you try to add two vectors together then the first element from vector 1 will be added to first element of vector 2 and so on (the fancy name for this is vectorization).\n\n```{r}\nnumbers <- c(1,2,3,4,5)\nnumbers2 <- c(6,7,8,9,10)\nnumbers + numbers2\n\n```\n\nIf the vectors have different lengths then R will start to recycle values from the shorter vectors. But it will output a warning if the length of one vector is not a multiple of the other vector.\n\n```{r}\nshort_v <- c(1,2,3)\nlong_v <- c(1,2,3,4,5)\nshort_v + long_v\n```\n\nIf you want to join two vectors together you can do it in 2 ways: the first one is with `c()` just like creating a new vector (and in fact it will simply create a new vector!). The other one is with `append()`. The first argument is the vector you want to append to and the second argument is the vector you want to append. `append()` also allows you to specify where to append the second vector with `after` argument that requires an index so you can put it e.g. inside the first vector rather than at the end\n\n```{r}\nappend(long_v, short_v, after = 2)\n```\n\nAnother thing about vectors is that they can be named: each element can have a name. This can be especially useful e.g. when the vector is a result of some statistical operations and you want to make it easier to understand which number means what (e.g. you want to put together the mean, median and mode in 1 vector). You can add names to elements in a vector simply with a `=`:\n\n```{r}\nnamed_vector <- c(\"element one\" = 1, \"element two\" = 2)\nnamed_vector\n```\n\nBefore we move on to factors lets introduce a few functions that can be useful for creating vectors:\n\n1.  `rep()` function allows you to repeat a given value or a vector n times. You can create large vectors with it easily:\n\n    ```{r}\n    long_v <- rep(c(1,2,3), 50)\n    summary(long_v)\n    ```\n\n2.  `seq()` allows you to create a sequence of numbers from some number to some number. You can either specify how long the sequence is to be and R will figure out the distances between numbers (`lenght.out` argument) or you can specify the distances between numbers with `by` argument and R will figure out the length of a resulting vector.\n\n    ```{r}\n    seq_v <- seq(0,1, length.out = 100)\n    summary(seq_v)\n    ```\n\n3.  `rnorm()` allows you to draw random numbers from a normal distribution with a specified mean and standard deviation (there is actually a whole family of drawing numbers from different distributions e.g. `rbinom()` for drawing from binomial distribution or `rbeta()` for drawing from beta distribution):\n\n    ```{r}\n    norm_v <- rnorm(100, mean = 5, sd = 2)\n    summary(norm_v)\n    ```\n\n## Factors\n\nFactors are much like vectors except that they are used for storing categorical values - they have levels. You can store variables such as country or experimental condition of participants in a factor. You can create a factor by calling `factor()` and passing it a vector as an argument.\n\n```{r}\nmy_vector <- c('a', 'b', 'a', 'b')\nmy_factor <- factor(my_vector)\nmy_factor\n```\n\nFactors can also have ordered levels. You can make an ordered factor by setting `ordered = T` argument when creating a factor. Notice how the output looks different now: it includes information on the order.\n\n```{r}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T)\nordered_fac\n```\n\nYou can also manually set the levels of a factor. You can do it when creating the factor. Notice that for ordered factor the order in which you pass the levels will determine the order of levels in the factor.\n\n```{r}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T, levels = c('low', 'high', 'medium'))\nordered_fac\n```\n\n## Matrices\n\nMatrices are a bit like vectors but they have two dimensions. They have rows and columns but treat them in the same way. Because of this they can store only one type of values (much like vectors). You can create a matrix from scratch with the `matrix()` function. This function takes a vectors of values as its input (these are the values we will fill our matrix with) and additional information on how the matrix has to look - how many columns and rows it should have and whether to fill the matrix with values by rows or columns\n\n```{r}\nnumbered_vector <- c(1,2,3,4,5,6,7,8,9)\nmy_matrix <- matrix(numbered_vector, nrow = 3, ncol = 3)\nmy_matrix\n```\n\nYou can also create a matrix by 'glueing' vectors together. You can bind them either as rows (`rbind()` function) or by columns (`cbind()` function). Notice that the names of the vectors will be used either as names of rows or columns.\n\n```{r}\nvec1 <- c(1,2,3)\nvec2 <- c(4,5,6)\ncbind(vec1, vec2)\n```\n\nSince we have two dimensions subsetting matrices can work both on rows and columns. The general idea is still the same but we have to specify whether we are subsetting rows or columns. Rows always come first, columns second separated by a comma like this `matrix[rows,columns]`. You can select ranges of rows or columns just like in a vector.\n\n```{r}\nmy_matrix[2,2]\n```\n\nIf you want to select all rows or columns you can leave the space blank. Remember to keep the comma though!\n\n```{r}\nmy_matrix[,3]\n```\n\nOperations on matrices follow similar rules like operations on vectors - they are element-wise by default (note that they are not your classical linear algebra operations!). E.g. if you multiply a matrix by a vector each row from the matrix will be multiplied by a given element from the vector (1st row by 1st value etc):\n\n```{r}\nmy_matrix * vec1\n```\n\n## Data frames\n\nIn a day to day analysis you will likely work with data frames most of the time. A data frame is like a matrix in that it has rows and columns but can store different types of values in each column (so that e.g. you can have some variables that are numeric and others that are text). A different way of thinking about data frames is as a list of vectors of the same length with each vector representing a different variable. Each row represents a different observation (e.g. participant).\n\nYou can create a data frame with `data.frame()` function passing all the variables as arguments. Lets create 3 vectors: author, title and year.\n\n```{r}\nauthor <- c('Allport', 'Heider', 'Lewin', 'Allport', 'Heider')\ntitle <- c('Nature of Prejudice', 'Psychology of interpersonal relations',\n           'Principles of Topological Psychology', 'Psychology of Rumor', 'The life of a psychologist: An autobiography')\nyear <- c(1954, 1958, 1936, 1947, 1983)\n\npsych_books <- data.frame(author, title, year)\npsych_books\n```\n\nSubsetting data frames works the same way as matrices. You can subset both on rows and columns. An important thing to remember (and one of the reasons a lot of people switch to tibbles which are kind of data frames+. We'll get to tibbles some time in the future) is that if you subset a single column the result will be a vector and not a dataframe. This sometimes is annoying if you are designing something that is supposed to work on data frames specifically.\n\nThere is one additional way of subsetting a data frame. Subsetting variables based on their position is tiresome because we rarely remember the order of all the columns (especially as our data frames get bigger). You can select a single variable using `$`:\n\n```{r}\npsych_books$author\n```\n\nUsing the `$` operator reflects a way of thinking about datasets that is pretty common: data frames are ordered collections of variables and each variable has its name. You can also use `$` to create new variables. Just assign a vector of values to a new name in your dataframe:\n\n```{r}\npsych_books$discipline <- c('intergroup relations', 'social psychology',\n                            'general psychology', 'social psychology',\n                            'biography')\npsych_books\n```\n\nRemember how we talked about element-wise operations on vectors? You can leverage it to easily create new variables that are results of operations on other variables. Thanks to this you can add a whole new variable that is a result of a mathematical operation in just one line (imagine adding a variable that is a sum of all points from a quiz for each student). Here's an example if we wanted to calculate how many years ago each book from our data frame was published:\n\n```{r}\npsych_books$book_age <- 2022 - psych_books$year\npsych_books\n```\n\nYou can also subset data frames based on condition. Lets say we want to find out which psychology books in our dataset are really old, say above 70. We can subset `psych_books` using `[]` but we need to add one more thing to specify our condition - we need to tell R which rows are the ones that fulfill our condition. We can do it with `which()`. It needs the condition as argument and will return numbers of rows from the data frame that fulfill the condition. We just need to put `which()` inside our subsetting to get the rows we want:\n\n```{r}\npsych_books[which(psych_books$book_age > 70),]\n```\n\n## Lists\n\nLists are the final type of basic data in R we will discuss here. They are the most versatile ones - they can store anything inside of them: single values, vectors, matrices, dataframes or even other lists! So they have 1 dimension but can store anything inside them. One important feature of lists is that they are ordered: you can access their elements by position. So you can think of lists as collections of objects but there aren't really limits to what these objects are (in fact data frames are very specific lists: they are collections of variables that have the same length and form a nice rectangular table). Lists are created with `list()`. Lets create a list of the plants in a house along with a value storing information on how many days ago did we last water them:\n\n```{r}\nlist_of_objects <- list(\n  plants = c('Calathea', 'Chamedora', 'Pilea', 'Philodendron'),\n  days_since_watering = 5\n)\nlist_of_objects\n```\n\nYou might encounter lists if you need to store a number of different things together. E.g. results of many statistical analyses are stored in lists because they might contain both information about the model, data and results. In fact as you dive deeper into R you will start to encounter more and more lists because they are very versatile.\n\nYou can access objects stored in lists in a few ways. You can use the `[]` you used for all other types of data. An important feature of this type of subsetting is that the result will always be a list (even if it has only 1 element). The other option is to use double square brackets `[[]]`. This will extract the object inside a list so the result won't be a list (you can think of it as 'getting deeper' into the list to extract the exact element you want).\n\n```{r collapse = FALSE}\nlist_of_objects[1]\nlist_of_objects[[1]]\n```\n\nIf the elements in your list are named you can also use `$` to extract them.\n\n```{r}\nlist_of_objects$days_since_watering\n```\n\n## Exercises\n\n1.  Suppose you ran a survey among your friends to what extent they agree with a statement \"I like pineapples\" and got 6 answers: \"agree\", \"disagree\", \"agree\", \"somewhat agree\", \"somewhat disagree\", \"disagree\". Choose the most appropriate type of object to store this information and save it as `answers`.\n\n    ```{r results = \"hide\"}\n    #| code-fold: true\n    #| code-summary: \"exercise 1\"\n\n    #' We need a data structure that can store a categorical variable with various levels.\n    #'  These levels also have some order to them. The best structure to store the answers is\n    #'   an ordered factor. We can create it by turning a vector into a factor,\n    #'    setting ordered argument to TRUE and specifying the levels of values.\n\n\n    pinapple_factor <- factor(c(\"agree\", \"disagree\", \"agree\", \"somewhat agree\", \"somewhat disagree\", \"disagree\"), ordered = TRUE, levels = c(\"disagree\", \"somewhat disagree\", \"somewhat agree\", \"agree\"))\n    pinapple_factor\n    ```\n\n2.  Create `v1` vector as 500 random numbers from normal distribution with mean of 3 and standard deviation of 1 and a `v2` vector as 500 random numbers from normal distribution with mean of 2.5 and standard deviation of 1.5. Append `v2` to `v1` to create one vector with 1000 values and save it as `v4`. Create a `v3` vector by repeating `c(\"a\", \"b\")` 500 times. Put together `v4` and `v3` as a dataframe. Then calculate which rows: `a` or `b` has a higher mean of `v4`?\n\n    ```{r results = \"hide\"}\n    #| code-fold: true\n    #| code-summary: \"exercise 2\"\n\n\n    #' We need to create 2 vectors, put them into a data frame and then calculate means for\n    #' subsetted data frame. We can create v4 by using rnorm() with appropriate arguments twice\n    #' and putting the resulting vectors together into v4.\n    #' v3 can be created with rep() function to repeat vector c(\"a\", \"b\") 500 times.\n    #' Then we need to put v3 and v4 into a dataframe with data.frame and save it as e.g. df.\n    #' Finally we need to calculate 2 means on subsetted dataframes. We can use which() inside\n    #' df[] to get the rows that match our condition (v1 == \"a\" or v1 == \"b\") and get the mean\n    #' of v4 from the subsetted data frames.\n\n    v1 <- rnorm(500, 3, 1)\n    v2 <- rnorm(500, 2.5, 1.5)\n\n    v4 <- c(v1, v2)\n\n    v3 <- rep(c(\"a\", \"b\"), 500)\n\n    df <- data.frame(v3, v4)\n\n    mean(df[which(df$v3 == \"a\"), \"v4\"])\n    mean(df[which(df$v3 == \"b\"), \"v4\"])\n\n    ```\n\n3.  Suppose you are interested in assessing how effective a given drug is. You have the following data: Out of 900 people who took the drug 657 got better. Out of 1000 people who did not take the drug, 540 got better. Represent this information as a matrix with columns coding those who took a drug or didn't take it and rows representing those who got better or not. Next calculate the percentage of people who got better in the drug and no drug conditions.\n\n    ```{r results = \"hide\"}\n    #| code-fold: true\n    #| code-summary: \"exercise 3\"\n\n    # we have all the information that we just need to put into a matrix.\n    # Remember that columns are supposed to code whether someone took the drug or not \n    # (so 1st column should sum to 900 and second to 1000) and rows code whether someone got better or not.\n    # We can get all the necesary values into the vector: we know how many people took the drug or\n    #not and how many got better in each condition. We can substract the appropriate numbers \n    # to get how many people took (or didn't take) the drug and did not get better\n    # we then need to create a column with 2 rows and carefully set the byrow argument\n    # so that it will match our input vector.\n\n    # Finally to get the percentages we need to divide values from the first row and appropriate column by the sum of appropriate column.\n\n\n\n    trial_matrix <- matrix(c(657, 900-657, 540, 1000 - 540), nrow = 2, byrow = F)\n\n    got_better_drug_percent <- trial_matrix[1,1]/sum(trial_matrix[,1])\n    got_better_nodrug_percent <- trial_matrix[1,2]/sum(trial_matrix[,2])\n\n    got_better_drug_percent\n    got_better_nodrug_percent\n    ```\n","srcMarkdownNoYaml":"\n\nSo far we have worked only with single values or objects storing only one value. However, usually you want to work with whole sets of values like variables or whole datasets. There is a number of types of data you can encounter in R which allow you to do that. A fairly easy way to orient yourself in the different types of data is:\n\n1.  how many dimensions does a given type have: you can think about it in terms of how many ways can you traverse a given object: if you can only move left or right then it has only one dimension. If you can move left or right and up or down then you have 2 dimensions.\n2.  What kinds of values can it store? Some types can store values of only 1 type while others can store multiple types of values a the same time.\n\n## Vectors\n\nThe most basic type of data is a vector. Vectors can store any number of values of the same type in 1 dimension. You can create a vector using `c()` function.\n\n```{r}\nmy_very_first_vector <- c(1,2,3)\nmy_very_first_vector\n```\n\nVectors are **indexed**: they have a first, second value etc. This means that you can access part of a vector -subset them. Subsetting is accomplished with `[]`. You can also subset a range of values from a vector wirh `[:]`:\n\n```{r}\nlong_vector <- c(1,2,3,4,5,6,7,8,9,10)\nlong_vector[3:5]\n```\n\nIf you try to put different types of values into one vector R will convert the types to a matching one. This is especially important when due to some mistake/error a single value of a different type gets lost in some other variable. Just a single value will trigger the whole variable to be converted!\n\n```{r}\nmy_vector <- c(1, TRUE, 'some text')\nmy_vector\nclass(my_vector)\n```\n\nYou can get a brief summary of a given vector with `summary()`. It will give slightly different information depending on what type of values is stored in a given vector:\n\n```{r}\nsummary(long_vector)\nsummary(my_vector)\n```\n\nYou can make pretty much the same operations on vectors as on single values. One of the great features of R is that by default it will make operations element wise - if you try to add two vectors together then the first element from vector 1 will be added to first element of vector 2 and so on (the fancy name for this is vectorization).\n\n```{r}\nnumbers <- c(1,2,3,4,5)\nnumbers2 <- c(6,7,8,9,10)\nnumbers + numbers2\n\n```\n\nIf the vectors have different lengths then R will start to recycle values from the shorter vectors. But it will output a warning if the length of one vector is not a multiple of the other vector.\n\n```{r}\nshort_v <- c(1,2,3)\nlong_v <- c(1,2,3,4,5)\nshort_v + long_v\n```\n\nIf you want to join two vectors together you can do it in 2 ways: the first one is with `c()` just like creating a new vector (and in fact it will simply create a new vector!). The other one is with `append()`. The first argument is the vector you want to append to and the second argument is the vector you want to append. `append()` also allows you to specify where to append the second vector with `after` argument that requires an index so you can put it e.g. inside the first vector rather than at the end\n\n```{r}\nappend(long_v, short_v, after = 2)\n```\n\nAnother thing about vectors is that they can be named: each element can have a name. This can be especially useful e.g. when the vector is a result of some statistical operations and you want to make it easier to understand which number means what (e.g. you want to put together the mean, median and mode in 1 vector). You can add names to elements in a vector simply with a `=`:\n\n```{r}\nnamed_vector <- c(\"element one\" = 1, \"element two\" = 2)\nnamed_vector\n```\n\nBefore we move on to factors lets introduce a few functions that can be useful for creating vectors:\n\n1.  `rep()` function allows you to repeat a given value or a vector n times. You can create large vectors with it easily:\n\n    ```{r}\n    long_v <- rep(c(1,2,3), 50)\n    summary(long_v)\n    ```\n\n2.  `seq()` allows you to create a sequence of numbers from some number to some number. You can either specify how long the sequence is to be and R will figure out the distances between numbers (`lenght.out` argument) or you can specify the distances between numbers with `by` argument and R will figure out the length of a resulting vector.\n\n    ```{r}\n    seq_v <- seq(0,1, length.out = 100)\n    summary(seq_v)\n    ```\n\n3.  `rnorm()` allows you to draw random numbers from a normal distribution with a specified mean and standard deviation (there is actually a whole family of drawing numbers from different distributions e.g. `rbinom()` for drawing from binomial distribution or `rbeta()` for drawing from beta distribution):\n\n    ```{r}\n    norm_v <- rnorm(100, mean = 5, sd = 2)\n    summary(norm_v)\n    ```\n\n## Factors\n\nFactors are much like vectors except that they are used for storing categorical values - they have levels. You can store variables such as country or experimental condition of participants in a factor. You can create a factor by calling `factor()` and passing it a vector as an argument.\n\n```{r}\nmy_vector <- c('a', 'b', 'a', 'b')\nmy_factor <- factor(my_vector)\nmy_factor\n```\n\nFactors can also have ordered levels. You can make an ordered factor by setting `ordered = T` argument when creating a factor. Notice how the output looks different now: it includes information on the order.\n\n```{r}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T)\nordered_fac\n```\n\nYou can also manually set the levels of a factor. You can do it when creating the factor. Notice that for ordered factor the order in which you pass the levels will determine the order of levels in the factor.\n\n```{r}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T, levels = c('low', 'high', 'medium'))\nordered_fac\n```\n\n## Matrices\n\nMatrices are a bit like vectors but they have two dimensions. They have rows and columns but treat them in the same way. Because of this they can store only one type of values (much like vectors). You can create a matrix from scratch with the `matrix()` function. This function takes a vectors of values as its input (these are the values we will fill our matrix with) and additional information on how the matrix has to look - how many columns and rows it should have and whether to fill the matrix with values by rows or columns\n\n```{r}\nnumbered_vector <- c(1,2,3,4,5,6,7,8,9)\nmy_matrix <- matrix(numbered_vector, nrow = 3, ncol = 3)\nmy_matrix\n```\n\nYou can also create a matrix by 'glueing' vectors together. You can bind them either as rows (`rbind()` function) or by columns (`cbind()` function). Notice that the names of the vectors will be used either as names of rows or columns.\n\n```{r}\nvec1 <- c(1,2,3)\nvec2 <- c(4,5,6)\ncbind(vec1, vec2)\n```\n\nSince we have two dimensions subsetting matrices can work both on rows and columns. The general idea is still the same but we have to specify whether we are subsetting rows or columns. Rows always come first, columns second separated by a comma like this `matrix[rows,columns]`. You can select ranges of rows or columns just like in a vector.\n\n```{r}\nmy_matrix[2,2]\n```\n\nIf you want to select all rows or columns you can leave the space blank. Remember to keep the comma though!\n\n```{r}\nmy_matrix[,3]\n```\n\nOperations on matrices follow similar rules like operations on vectors - they are element-wise by default (note that they are not your classical linear algebra operations!). E.g. if you multiply a matrix by a vector each row from the matrix will be multiplied by a given element from the vector (1st row by 1st value etc):\n\n```{r}\nmy_matrix * vec1\n```\n\n## Data frames\n\nIn a day to day analysis you will likely work with data frames most of the time. A data frame is like a matrix in that it has rows and columns but can store different types of values in each column (so that e.g. you can have some variables that are numeric and others that are text). A different way of thinking about data frames is as a list of vectors of the same length with each vector representing a different variable. Each row represents a different observation (e.g. participant).\n\nYou can create a data frame with `data.frame()` function passing all the variables as arguments. Lets create 3 vectors: author, title and year.\n\n```{r}\nauthor <- c('Allport', 'Heider', 'Lewin', 'Allport', 'Heider')\ntitle <- c('Nature of Prejudice', 'Psychology of interpersonal relations',\n           'Principles of Topological Psychology', 'Psychology of Rumor', 'The life of a psychologist: An autobiography')\nyear <- c(1954, 1958, 1936, 1947, 1983)\n\npsych_books <- data.frame(author, title, year)\npsych_books\n```\n\nSubsetting data frames works the same way as matrices. You can subset both on rows and columns. An important thing to remember (and one of the reasons a lot of people switch to tibbles which are kind of data frames+. We'll get to tibbles some time in the future) is that if you subset a single column the result will be a vector and not a dataframe. This sometimes is annoying if you are designing something that is supposed to work on data frames specifically.\n\nThere is one additional way of subsetting a data frame. Subsetting variables based on their position is tiresome because we rarely remember the order of all the columns (especially as our data frames get bigger). You can select a single variable using `$`:\n\n```{r}\npsych_books$author\n```\n\nUsing the `$` operator reflects a way of thinking about datasets that is pretty common: data frames are ordered collections of variables and each variable has its name. You can also use `$` to create new variables. Just assign a vector of values to a new name in your dataframe:\n\n```{r}\npsych_books$discipline <- c('intergroup relations', 'social psychology',\n                            'general psychology', 'social psychology',\n                            'biography')\npsych_books\n```\n\nRemember how we talked about element-wise operations on vectors? You can leverage it to easily create new variables that are results of operations on other variables. Thanks to this you can add a whole new variable that is a result of a mathematical operation in just one line (imagine adding a variable that is a sum of all points from a quiz for each student). Here's an example if we wanted to calculate how many years ago each book from our data frame was published:\n\n```{r}\npsych_books$book_age <- 2022 - psych_books$year\npsych_books\n```\n\nYou can also subset data frames based on condition. Lets say we want to find out which psychology books in our dataset are really old, say above 70. We can subset `psych_books` using `[]` but we need to add one more thing to specify our condition - we need to tell R which rows are the ones that fulfill our condition. We can do it with `which()`. It needs the condition as argument and will return numbers of rows from the data frame that fulfill the condition. We just need to put `which()` inside our subsetting to get the rows we want:\n\n```{r}\npsych_books[which(psych_books$book_age > 70),]\n```\n\n## Lists\n\nLists are the final type of basic data in R we will discuss here. They are the most versatile ones - they can store anything inside of them: single values, vectors, matrices, dataframes or even other lists! So they have 1 dimension but can store anything inside them. One important feature of lists is that they are ordered: you can access their elements by position. So you can think of lists as collections of objects but there aren't really limits to what these objects are (in fact data frames are very specific lists: they are collections of variables that have the same length and form a nice rectangular table). Lists are created with `list()`. Lets create a list of the plants in a house along with a value storing information on how many days ago did we last water them:\n\n```{r}\nlist_of_objects <- list(\n  plants = c('Calathea', 'Chamedora', 'Pilea', 'Philodendron'),\n  days_since_watering = 5\n)\nlist_of_objects\n```\n\nYou might encounter lists if you need to store a number of different things together. E.g. results of many statistical analyses are stored in lists because they might contain both information about the model, data and results. In fact as you dive deeper into R you will start to encounter more and more lists because they are very versatile.\n\nYou can access objects stored in lists in a few ways. You can use the `[]` you used for all other types of data. An important feature of this type of subsetting is that the result will always be a list (even if it has only 1 element). The other option is to use double square brackets `[[]]`. This will extract the object inside a list so the result won't be a list (you can think of it as 'getting deeper' into the list to extract the exact element you want).\n\n```{r collapse = FALSE}\nlist_of_objects[1]\nlist_of_objects[[1]]\n```\n\nIf the elements in your list are named you can also use `$` to extract them.\n\n```{r}\nlist_of_objects$days_since_watering\n```\n\n## Exercises\n\n1.  Suppose you ran a survey among your friends to what extent they agree with a statement \"I like pineapples\" and got 6 answers: \"agree\", \"disagree\", \"agree\", \"somewhat agree\", \"somewhat disagree\", \"disagree\". Choose the most appropriate type of object to store this information and save it as `answers`.\n\n    ```{r results = \"hide\"}\n    #| code-fold: true\n    #| code-summary: \"exercise 1\"\n\n    #' We need a data structure that can store a categorical variable with various levels.\n    #'  These levels also have some order to them. The best structure to store the answers is\n    #'   an ordered factor. We can create it by turning a vector into a factor,\n    #'    setting ordered argument to TRUE and specifying the levels of values.\n\n\n    pinapple_factor <- factor(c(\"agree\", \"disagree\", \"agree\", \"somewhat agree\", \"somewhat disagree\", \"disagree\"), ordered = TRUE, levels = c(\"disagree\", \"somewhat disagree\", \"somewhat agree\", \"agree\"))\n    pinapple_factor\n    ```\n\n2.  Create `v1` vector as 500 random numbers from normal distribution with mean of 3 and standard deviation of 1 and a `v2` vector as 500 random numbers from normal distribution with mean of 2.5 and standard deviation of 1.5. Append `v2` to `v1` to create one vector with 1000 values and save it as `v4`. Create a `v3` vector by repeating `c(\"a\", \"b\")` 500 times. Put together `v4` and `v3` as a dataframe. Then calculate which rows: `a` or `b` has a higher mean of `v4`?\n\n    ```{r results = \"hide\"}\n    #| code-fold: true\n    #| code-summary: \"exercise 2\"\n\n\n    #' We need to create 2 vectors, put them into a data frame and then calculate means for\n    #' subsetted data frame. We can create v4 by using rnorm() with appropriate arguments twice\n    #' and putting the resulting vectors together into v4.\n    #' v3 can be created with rep() function to repeat vector c(\"a\", \"b\") 500 times.\n    #' Then we need to put v3 and v4 into a dataframe with data.frame and save it as e.g. df.\n    #' Finally we need to calculate 2 means on subsetted dataframes. We can use which() inside\n    #' df[] to get the rows that match our condition (v1 == \"a\" or v1 == \"b\") and get the mean\n    #' of v4 from the subsetted data frames.\n\n    v1 <- rnorm(500, 3, 1)\n    v2 <- rnorm(500, 2.5, 1.5)\n\n    v4 <- c(v1, v2)\n\n    v3 <- rep(c(\"a\", \"b\"), 500)\n\n    df <- data.frame(v3, v4)\n\n    mean(df[which(df$v3 == \"a\"), \"v4\"])\n    mean(df[which(df$v3 == \"b\"), \"v4\"])\n\n    ```\n\n3.  Suppose you are interested in assessing how effective a given drug is. You have the following data: Out of 900 people who took the drug 657 got better. Out of 1000 people who did not take the drug, 540 got better. Represent this information as a matrix with columns coding those who took a drug or didn't take it and rows representing those who got better or not. Next calculate the percentage of people who got better in the drug and no drug conditions.\n\n    ```{r results = \"hide\"}\n    #| code-fold: true\n    #| code-summary: \"exercise 3\"\n\n    # we have all the information that we just need to put into a matrix.\n    # Remember that columns are supposed to code whether someone took the drug or not \n    # (so 1st column should sum to 900 and second to 1000) and rows code whether someone got better or not.\n    # We can get all the necesary values into the vector: we know how many people took the drug or\n    #not and how many got better in each condition. We can substract the appropriate numbers \n    # to get how many people took (or didn't take) the drug and did not get better\n    # we then need to create a column with 2 rows and carefully set the byrow argument\n    # so that it will match our input vector.\n\n    # Finally to get the percentages we need to divide values from the first row and appropriate column by the sum of appropriate column.\n\n\n\n    trial_matrix <- matrix(c(657, 900-657, 540, 1000 - 540), nrow = 2, byrow = F)\n\n    got_better_drug_percent <- trial_matrix[1,1]/sum(trial_matrix[,1])\n    got_better_nodrug_percent <- trial_matrix[1,2]/sum(trial_matrix[,2])\n\n    got_better_drug_percent\n    got_better_nodrug_percent\n    ```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"monokai","output-file":"03data_types.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.549","editor":"visual","theme":"theme.scss","toc-location":"left","page-layout":"full","title":"Types of data","author":"Michal Wypych"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}