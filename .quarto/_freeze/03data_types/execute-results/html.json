{
  "hash": "8e8505deae8d82ff6c2a59a2eebbcc9b",
  "result": {
    "markdown": "---\ntitle: \"Types of data\"\nauthor: \"Michal Wypych\"\n---\n\n\nSo far we have worked only with single values or objects storing only one value. However, usually you want to work with whole sets of values like variables or whole datasets. There is a number of types of data you can encounter in R which allow you to do that. A fairly easy way to orient yourself in the different types of data is:\n\n1.  how many dimensions does a given type have: you can think about it in terms of how many ways can you traverse a given object: if you can only move left or right then it has only one dimension. If you can move left or right and up or down then you have 2 dimensions.\n2.  What kinds of values can it store? Some types can store values of only 1 type while others can store multiple types of values a the same time.\n\n## Vectors\n\nThe most basic type of data is a vector. Vectors can store any number of values of the same type in 1 dimension. You can create a vector using `c()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_very_first_vector <- c(1,2,3)\nmy_very_first_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nVectors are **indexed**: they have a first, second value etc. This means that you can access part of a vector -subset them. Subsetting is accomplished with `[]`. You can also subset a range of values from a vector wirh `[:]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector <- c(1,2,3,4,5,6,7,8,9,10)\nlong_vector[3:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n:::\n\n\nIf you try to put different types of values into one vector R will convert the types to a matching one. This is especially important when due to some mistake/error a single value of a different type gets lost in some other variable. Just a single value will trigger the whole variable to be converted!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, TRUE, 'some text')\nmy_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"         \"TRUE\"      \"some text\"\n```\n:::\n\n```{.r .cell-code}\nclass(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\nYou can get a brief summary of a given vector with `summary()`. It will give slightly different information depending on what type of values is stored in a given vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(long_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    3.25    5.50    5.50    7.75   10.00 \n```\n:::\n\n```{.r .cell-code}\nsummary(my_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Length     Class      Mode \n        3 character character \n```\n:::\n:::\n\n\nYou can make pretty much the same operations on vectors as on single values. One of the great features of R is that by default it will make operations element wise - if you try to add two vectors together then the first element from vector 1 will be added to first element of vector 2 and so on (the fancy name for this is vectorization).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1,2,3,4,5)\nnumbers2 <- c(6,7,8,9,10)\nnumbers + numbers2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7  9 11 13 15\n```\n:::\n:::\n\n\nIf the vectors have different lengths then R will start to recycle values from the shorter vectors. But it will output a warning if the length of one vector is not a multiple of the other vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshort_v <- c(1,2,3)\nlong_v <- c(1,2,3,4,5)\nshort_v + long_v\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in short_v + long_v: długość dłuszego obiektu nie jest wielokrotnością\ndługości krótszego obiektu\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 5 7\n```\n:::\n:::\n\n\nIf you want to join two vectors together you can do it in 2 ways: the first one is with `c()` just like creating a new vector (and in fact it will simply create a new vector!). The other one is with `append()`. The first argument is the vector you want to append to and the second argument is the vector you want to append. `append()` also allows you to specify where to append the second vector with `after` argument that requires an index so you can put it e.g. inside the first vector rather than at the end\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappend(long_v, short_v, after = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 1 2 3 3 4 5\n```\n:::\n:::\n\n\nAnother thing about vectors is that they can be named: each element can have a name. This can be especially useful e.g. when the vector is a result of some statistical operations and you want to make it easier to understand which number means what (e.g. you want to put together the mean, median and mode in 1 vector). You can add names to elements in a vector simply with a `=`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_vector <- c(\"element one\" = 1, \"element two\" = 2)\nnamed_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nelement one element two \n          1           2 \n```\n:::\n:::\n\n\nBefore we move on to factors lets introduce a few functions that can be useful for creating vectors:\n\n1.  `rep()` function allows you to repeat a given value or a vector n times. You can create large vectors with it easily:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    long_v <- rep(c(1,2,3), 50)\n    summary(long_v)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n          1       1       2       2       3       3 \n    ```\n    :::\n    :::\n\n\n2.  `seq()` allows you to create a sequence of numbers from some number to some number. You can either specify how long the sequence is to be and R will figure out the distances between numbers (`lenght.out` argument) or you can specify the distances between numbers with `by` argument and R will figure out the length of a resulting vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    seq_v <- seq(0,1, length.out = 100)\n    summary(seq_v)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n       0.00    0.25    0.50    0.50    0.75    1.00 \n    ```\n    :::\n    :::\n\n\n3.  `rnorm()` allows you to draw random numbers from a normal distribution with a specified mean and standard deviation (there is actually a whole family of drawing numbers from different distributions e.g. `rbinom()` for drawing from binomial distribution or `rbeta()` for drawing from beta distribution):\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    norm_v <- rnorm(100, mean = 5, sd = 2)\n    summary(norm_v)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    -0.5497  3.7977  5.0062  5.0760  6.3953  9.7307 \n    ```\n    :::\n    :::\n\n\n## Factors\n\nFactors are much like vectors except that they are used for storing categorical values - they have levels. You can store variables such as country or experimental condition of participants in a factor. You can create a factor by calling `factor()` and passing it a vector as an argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c('a', 'b', 'a', 'b')\nmy_factor <- factor(my_vector)\nmy_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] a b a b\nLevels: a b\n```\n:::\n:::\n\n\nFactors can also have ordered levels. You can make an ordered factor by setting `ordered = T` argument when creating a factor. Notice how the output looks different now: it includes information on the order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T)\nordered_fac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] low  high high low  low \nLevels: high < low\n```\n:::\n:::\n\n\nYou can also manually set the levels of a factor. You can do it when creating the factor. Notice that for ordered factor the order in which you pass the levels will determine the order of levels in the factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T, levels = c('low', 'high', 'medium'))\nordered_fac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] low  high high low  low \nLevels: low < high < medium\n```\n:::\n:::\n\n\n## Matrices\n\nMatrices are a bit like vectors but they have two dimensions. They have rows and columns but treat them in the same way. Because of this they can store only one type of values (much like vectors). You can create a matrix from scratch with the `matrix()` function. This function takes a vectors of values as its input (these are the values we will fill our matrix with) and additional information on how the matrix has to look - how many columns and rows it should have and whether to fill the matrix with values by rows or columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbered_vector <- c(1,2,3,4,5,6,7,8,9)\nmy_matrix <- matrix(numbered_vector, nrow = 3, ncol = 3)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n\nYou can also create a matrix by 'glueing' vectors together. You can bind them either as rows (`rbind()` function) or by columns (`cbind()` function). Notice that the names of the vectors will be used either as names of rows or columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec1 <- c(1,2,3)\nvec2 <- c(4,5,6)\ncbind(vec1, vec2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     vec1 vec2\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n\nSince we have two dimensions subsetting matrices can work both on rows and columns. The general idea is still the same but we have to specify whether we are subsetting rows or columns. Rows always come first, columns second separated by a comma like this `matrix[rows,columns]`. You can select ranges of rows or columns just like in a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nIf you want to select all rows or columns you can leave the space blank. Remember to keep the comma though!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7 8 9\n```\n:::\n:::\n\n\nOperations on matrices follow similar rules like operations on vectors - they are element-wise by default (note that they are not your classical linear algebra operations!). E.g. if you multiply a matrix by a vector each row from the matrix will be multiplied by a given element from the vector (1st row by 1st value etc):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix * vec1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    4   10   16\n[3,]    9   18   27\n```\n:::\n:::\n\n\n## Data frames\n\nIn a day to day analysis you will likely work with data frames most of the time. A data frame is like a matrix in that it has rows and columns but can store different types of values in each column (so that e.g. you can have some variables that are numeric and others that are text). A different way of thinking about data frames is as a list of vectors of the same length with each vector representing a different variable. Each row represents a different observation (e.g. participant).\n\nYou can create a data frame with `data.frame()` function passing all the variables as arguments. Lets create 3 vectors: author, title and year.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauthor <- c('Allport', 'Heider', 'Lewin', 'Allport', 'Heider')\ntitle <- c('Nature of Prejudice', 'Psychology of interpersonal relations',\n           'Principles of Topological Psychology', 'Psychology of Rumor', 'The life of a psychologist: An autobiography')\nyear <- c(1954, 1958, 1936, 1947, 1983)\n\npsych_books <- data.frame(author, title, year)\npsych_books\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                        title year\n1 Allport                          Nature of Prejudice 1954\n2  Heider        Psychology of interpersonal relations 1958\n3   Lewin         Principles of Topological Psychology 1936\n4 Allport                          Psychology of Rumor 1947\n5  Heider The life of a psychologist: An autobiography 1983\n```\n:::\n:::\n\n\nSubsetting data frames works the same way as matrices. You can subset both on rows and columns. An important thing to remember (and one of the reasons a lot of people switch to tibbles which are kind of data frames+. We'll get to tibbles some time in the future) is that if you subset a single column the result will be a vector and not a dataframe. This sometimes is annoying if you are designing something that is supposed to work on data frames specifically.\n\nThere is one additional way of subsetting a data frame. Subsetting variables based on their position is tiresome because we rarely remember the order of all the columns (especially as our data frames get bigger). You can select a single variable using `$`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books$author\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Allport\" \"Heider\"  \"Lewin\"   \"Allport\" \"Heider\" \n```\n:::\n:::\n\n\nUsing the `$` operator reflects a way of thinking about datasets that is pretty common: data frames are ordered collections of variables and each variable has its name. You can also use `$` to create new variables. Just assign a vector of values to a new name in your dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books$discipline <- c('intergroup relations', 'social psychology',\n                            'general psychology', 'social psychology',\n                            'biography')\npsych_books\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                        title year\n1 Allport                          Nature of Prejudice 1954\n2  Heider        Psychology of interpersonal relations 1958\n3   Lewin         Principles of Topological Psychology 1936\n4 Allport                          Psychology of Rumor 1947\n5  Heider The life of a psychologist: An autobiography 1983\n            discipline\n1 intergroup relations\n2    social psychology\n3   general psychology\n4    social psychology\n5            biography\n```\n:::\n:::\n\n\nRemember how we talked about element-wise operations on vectors? You can leverage it to easily create new variables that are results of operations on other variables. Thanks to this you can add a whole new variable that is a result of a mathematical operation in just one line (imagine adding a variable that is a sum of all points from a quiz for each student). Here's an example if we wanted to calculate how many years ago each book from our data frame was published:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books$book_age <- 2022 - psych_books$year\npsych_books\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                        title year\n1 Allport                          Nature of Prejudice 1954\n2  Heider        Psychology of interpersonal relations 1958\n3   Lewin         Principles of Topological Psychology 1936\n4 Allport                          Psychology of Rumor 1947\n5  Heider The life of a psychologist: An autobiography 1983\n            discipline book_age\n1 intergroup relations       68\n2    social psychology       64\n3   general psychology       86\n4    social psychology       75\n5            biography       39\n```\n:::\n:::\n\n\nYou can also subset data frames based on condition. Lets say we want to find out which psychology books in our dataset are really old, say above 70. We can subset `psych_books` using `[]` but we need to add one more thing to specify our condition - we need to tell R which rows are the ones that fulfill our condition. We can do it with `which()`. It needs the condition as argument and will return numbers of rows from the data frame that fulfill the condition. We just need to put `which()` inside our subsetting to get the rows we want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsych_books[which(psych_books$book_age > 70),]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   author                                title year         discipline book_age\n3   Lewin Principles of Topological Psychology 1936 general psychology       86\n4 Allport                  Psychology of Rumor 1947  social psychology       75\n```\n:::\n:::\n\n\n## Lists\n\nLists are the final type of basic data in R we will discuss here. They are the most versatile ones - they can store anything inside of them: single values, vectors, matrices, dataframes or even other lists! So they have 1 dimension but can store anything inside them. One important feature of lists is that they are ordered: you can access their elements by position. So you can think of lists as collections of objects but there aren't really limits to what these objects are (in fact data frames are very specific lists: they are collections of variables that have the same length and form a nice rectangular table). Lists are created with `list()`. Lets create a list of the plants in a house along with a value storing information on how many days ago did we last water them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_objects <- list(\n  plants = c('Calathea', 'Chamedora', 'Pilea', 'Philodendron'),\n  days_since_watering = 5\n)\nlist_of_objects\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$plants\n[1] \"Calathea\"     \"Chamedora\"    \"Pilea\"        \"Philodendron\"\n\n$days_since_watering\n[1] 5\n```\n:::\n:::\n\n\nYou might encounter lists if you need to store a number of different things together. E.g. results of many statistical analyses are stored in lists because they might contain both information about the model, data and results. In fact as you dive deeper into R you will start to encounter more and more lists because they are very versatile.\n\nYou can access objects stored in lists in a few ways. You can use the `[]` you used for all other types of data. An important feature of this type of subsetting is that the result will always be a list (even if it has only 1 element). The other option is to use double square brackets `[[]]`. This will extract the object inside a list so the result won't be a list (you can think of it as 'getting deeper' into the list to extract the exact element you want).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_objects[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$plants\n[1] \"Calathea\"     \"Chamedora\"    \"Pilea\"        \"Philodendron\"\n```\n:::\n\n```{.r .cell-code}\nlist_of_objects[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Calathea\"     \"Chamedora\"    \"Pilea\"        \"Philodendron\"\n```\n:::\n:::\n\n\nIf the elements in your list are named you can also use `$` to extract them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_of_objects$days_since_watering\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n## Exercises\n\n1.  Suppose you ran a survey among your friends to what extent they agree with a statement \"I like pineapples\" and got 6 answers: \"agree\", \"disagree\", \"agree\", \"somewhat agree\", \"somewhat disagree\", \"disagree\". Choose the most appropriate type of object to store this information and save it as `answers`.\n2.  Create `v1` vector as 500 random numbers from normal distribution with mean of 3 and standard deviation of 1 and a `v2` vector as 500 random numbers from normal distribution with mean of 2.5 and standard deviation of 1.5. Append `v2` to `v1` to create one vector with 1000 values and save it as `v4`. Create a `v3` vector by repeating `c(\"a\", \"b\")` 500 times. Put together `v4` and `v3` as a dataframe. Then calculate which rows: `a` or `b` has a higher mean of `v4`?\n3.  Suppose you are interested in assessing how effective a given drug is. You have the following data: Out of 900 people who took the drug 657 got better. Out of 1000 people who did not take the drug, 540 got better. Represent this information as a matrix with columns coding those who took a drug or didn't take it and rows representing those who got better or not. Next calculate the percentage of people who got better in the drug and no drug conditions.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}