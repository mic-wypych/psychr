{
  "hash": "baef61c9f9a7b0eb14eec0e340e38cd0",
  "result": {
    "markdown": "---\ntitle: \"Storing data\"\nauthor: \"Michal Wypych\"\n---\n\n\n# Types of data\n\nSo far we have worked only with single values. However, usually you want to work with whole sets of values like variables or whole datasets. There is a number of types of data you can encounter in R.\n\n## Vectors\n\nThe most basic type of data is a vector. Vectors can store any number of values of the same type. You can create a vector using `c()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_very_first_vector <- c(1,2,3)\nmy_very_first_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\nVectors are ordered: they have a first, second value etc. This means that you can access part of a vector -subset them. Subsetting is accomplished with `[]`. You can get a third element of a vector. You can also subset a range of values from a vector wirh `:`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_vector <- c(1,2,3,4,5,6,7,8,9,10)\nlong_vector[3:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n:::\n\n\nIf you try to put different types of values into one vector R will convert the types to a matching one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c(1, TRUE, 'some text')\nmy_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"         \"TRUE\"      \"some text\"\n```\n:::\n:::\n\n\nOperations on vectors: you can make the same operations on vectors as on single values. One of the great features of R is that by default it will make operations element wise - if you try to add two vectors together then the first element from vector 1 will be added to first element of vector 2 and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1,2,3,4,5)\nnumbers2 <- c(6,7,8,9,10)\nnumbers + numbers2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  7  9 11 13 15\n```\n:::\n:::\n\n\nIf the vectors have different lengths then R will start to recycle values from the shorter vectors. But it will output a warning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshort_v <- c(1,2,3)\nlong_v <- c(1,2,3,4,5)\nshort_v + long_v\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in short_v + long_v: długość dłuszego obiektu nie jest wielokrotnością\ndługości krótszego obiektu\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 5 7\n```\n:::\n:::\n\n\n## Factors\n\nFactors are much like vectors except that they are used for storing categorical values - they have levels. You can create a factor by calling `factor()` and passing it a vector as an argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_vector <- c('a', 'b', 'a', 'b')\nmy_factor <- factor(my_vector)\nmy_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] a b a b\nLevels: a b\n```\n:::\n:::\n\n\nYou can set levels of a factor or specify order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nordered_vec <- c('low', 'high', 'high', 'low', 'low')\nordered_fac <- factor(ordered_vec, ordered = T)\nordered_fac\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] low  high high low  low \nLevels: high < low\n```\n:::\n:::\n\n\nNotice how the output looks different now: it includes information on the order.\n\n## Matrices\n\nWhat is a matrix?\n\nMatrices are a bit like vectors but they have two dimensions. They can store only one type of values but they have rows and columns.\n\nHow to create a matrix?\n\n\n::: {.cell}\n\n:::\n\n\nSubsetting matrices\n\nSince we have two dimensions subsetting can work both on rows and matrices. The general idea is still the same but we have to specify whether we are subsetting rows or columns. Rows always come first, columns second separated by a comma.\n\n## Data frames\n\nIn a day to day analysis you will most likely work with data frames most of the time. A data frame is like a matrix in that it has rows and columns but can store different types of values in each column (so that e.g. you can have some variables that are numeric and others that are text). A different way of thinking about data frames is as a list of vectors of the same length with each vector representing a different variable.\n\n\n::: {.cell}\n\n:::\n\n\nsubsetting data frames\n\n## Lists\n\nLists are the final type of basic data in R. They are the most versatile ones - they can store anything inside of them: single values, vectors, matrices, dataframes or even other lists! One important feature of lists is that they are ordered: you can access their elements by position.\n\n\n::: {.cell}\n\n:::\n\n\nYou might encounter lists if you need to store a number of different things together. E.g. results of many statistical analyses are stored in lists.\n\nSubsetting lists can be done the same way\n\nCreating and subsetting lists\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}