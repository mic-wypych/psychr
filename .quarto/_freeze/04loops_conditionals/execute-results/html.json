{
  "hash": "6bb2e2857f1cdea75a9a955c33ef7177",
  "result": {
    "markdown": "---\ntitle: \"Loops and conditionals\"\nauthor: \"Michal Wypych\"\n---\n\n\n# The flow of code\n\nNow you know how to create different kinds of objects and how to perform simple operations with them. However, very often you want to add more control over how operations are ran in R. You might want to execute a command only if a condition is satisfied. Or you might want to make the same operations for a number of elements. These are the kinds of situations for which you want to use flow control. What this refers to is basically altering how the code is executed. In a regular situations all commands from your script are executed from the first line all the way down to the last line. Flow control alters that either by specifying conditinal statements that tell R to execute a given chunk of code only if a condition is met or by using loops that repeat a given chunk of code.\n\n## Conditional statements\n\nAnother way conditional statements are referred to which may be more intuitive are if else statements. They allow you to tell R to execute given chunk of code if a condition is met and to do something else if the condition is not met.\n\nThe general logic of conditional statements looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) {\n  Do this\n  And do this\n}\n```\n:::\n\n\nA single if statement can have multiple conditions chained together with `|` and `&` operators. So, for example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\ny <- -5\n\nif (x > 0 & y < 0) {\n  print(\"Hooray!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hooray!\"\n```\n:::\n:::\n\n\nIn many situations you want to state what is to be done if a condition is met and what to do otherwise. This turns your statement into an if else one. The only difference is that after the if statement you add else and specify what to do then in curly brackets. With this knowledge you can already create the rules for a simple game like paper, rock, scissors!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#set the choice for each player\nplayer1 <- 'scissors'\nplayer2 <- 'rock'\n\n#define an if statement that outputs the result of the game\nif (player1 == player2) {\n  print('draw')\n} else if ((player1 == 'scissors' & player2 == 'paper') |\n           (player1 == 'paper' & player2 == 'rock') |\n           (player1 == 'rock' & player2 == 'scissors')) {\n  print('player 1 wins')\n} else if ((player2 == 'scissors' & player1 == 'paper') |\n           (player2 == 'paper' & player1 == 'rock') |\n           (player2 == 'rock' & player1 == 'scissors')) {\n  print('player 2 wins')\n} else {\n  print('these are not allowed moves')\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"player 2 wins\"\n```\n:::\n:::\n\n\nTake a moment to study the code above. Notice what kinds of conditions are included in that statement. When writing an if statement it's a good idea to consider all possible situations and how your if statement maps to them. In a paper, rock, scissors game you can have 3 outcomes: both players choose the same option (a draw), player 1 wins or player 2 wins. Notice that the code above includes also a fourth options specified in the last else statement. What if someone makes a typo and writes `rook` instead of `rock`? That last else statement safeguards us for such situations. If we didn't include it and someone made a type then our if else statement wouldn't produce anything. You can play around with different values of player1 and player2 to see the results.\n\nOne more thing about `if else` statements: in many situations it is a good idea to give some thought to what exactly a given statement is supposed to do and how large the statement needs to be. A good example is an `if` statement that is supposed to run some check (e.g. make sure that we are working with a numeric value) and stop execution if it detects a problem. Imagine a situation in which we want to do some calculations on numbers and want to make sure that we are indeed working with numeric values. you could design an `if else` statement that would do it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 'not a number'\ny <- 3\nif ((class(x) != 'numeric') | (class(y) != 'numeric')) {\n  stop('This is not a number!')\n} else {\n  x + y\n}\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): This is not a number!\n```\n:::\n:::\n\n\nTake a moment to look at the code above. Do you think it is good? It certainly gets the job done. Do you think it could be simplified?\n\nIn fact the `else` part is redundant in this case. The if statement runs the check on `x` and `y` and stops execution of the code if any of them is not numeric. If both values are numeric the execution of code simply proceeds. In this case adding an `else` statement makes the code harder to read (and imagine what would happen if we had to perform a number of checks like this! We would need a lot of `if else` statements that would make everything even less clear). The code below does the same thing as the `if else` statement above but is more clear.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 'not a number'\ny <- 3\nif ((class(x) != 'numeric') | (class(y) != 'numeric')) {\n  stop('This is not a number!')\n}\n## Error in eval(expr, envir, enclos): This is not a number!\nx + y\n## Error in x + y: argument nieliczbowy przekazany do operatora dwuargumentowego\n```\n:::\n\n\n## Loops\n\nAnother way of controlling the flow of your code is by repeating a given chunk of code. There are two basic ways to do that: repeat something a number of times or keep repeating until some condition is met. The first way is called a for loop and the second one a while loop.\n\n### for loops\n\nBefore we make our first for loop lets take a moment to see when a for loop is not needed. Recall again that a lot of things in R are vectorized. This means that operations on vectors are conducted element-wise. Thanks to this if you want to e.g. add 5 to each value stored in a numeric vector (in the language of a for loop: for every element of a vector, add 5 to it) you can just write `vector_name + 5`. No need for more complicated, explicit repetition. However, there are situations in which you have to make an explicit for loop to repeat something n times. The general structure of a for loops looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in object) {\n  Do this to each element\n}\n```\n:::\n\n\nIt's worth keeping in mind what the `i` in the for loop is. In the example above `i` will be every consecutive element of object. However we could do a similar thing with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:length(object)) {\n  do this to object[i]\n}\n```\n:::\n\n\nNow each `i` is a number from 1 to thew length of `object` and we access each element of `object` by using a proper (`ith`) index. Which way of running a for loop you choose might depend on the context. looping explicitly over elements of an object rather than indexes can be more intuitive but imagine you don't want to do something to every element of an object but only to to a subset (e.g. from 3rd onwards). Doing it with indexes is easier. Generally the best approach is to think what you need first and code second, not the other way around.\n\n### While loops\n\nWhile loops will keep executing a given chunk of code as long as some condition is met.\n\nWe can use a while loop to make a very simple simulation. Lets say we want to see how temperatures change from a given temperature (lets say 20 degrees Celsius) across time and that we represent time by some random change from each previous temperature. We can create a vector with such predicted temperatures and see how long it takes for it to reach a certain level (lets say 30 degrees Celsius). We represent the change by adding a random value from a normal distribution with mean = .05 and standard deviation = .5 (this is what the `rnorm(1,.05,.5)` does). The while loop would look something like this. We first create the initial value and a vector to store all temperatures and next we keep adding the random value to our temperature and storing all temperatures until it reaches 30. The last line tells R to plot all the temperatures as a line plot. This is of course a very, very very simplistic simulation (temperatures don't change in such a simple way) but it works to show you the idea behind while loops. We can then calculate e.g. how long it took for the temperature to reach a certain level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nC <- 20\nresults <- c(20)\nwhile (C < 30) {\n  C <- C + rnorm(1,.05,.5)\n  results <- c(results, C)\n}\n\nplot(results, type = 'line', lwd = 2, col=4, xlab = \"days\", ylab = \"temperature\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in plot.xy(xy, type, ...): plot type 'line' will be truncated to first\ncharacter\n```\n:::\n\n::: {.cell-output-display}\n![](04loops_conditionals_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nBecause while loops do not have a fixed number of iteration they can potentially run infinitely. This is usually not something we want so it's a good idea to make sure that your while loop eventually stops. In case you do get stuck in an infinite loop you can press `Esc` in your console and this should make RStudio stop the loop by force.\n\nTruth is while loops are not common in R. You will rarely find yourself in situation where you need to perform some actions while a given condition is true (e.g. keep a program running until a user presses exit; keep displaying a board of a game until a player makes a move). However, it's still good to know what while loops are so that you will know one when you see it.\n\n## Apply family\n\nThere is a special family of functions in R that makes working with for loops a bit easier. These functions let you specify what to loop over and what function to apply to each element but in a function rather than a whole loop with all the curly brackets and stuff.\n\nThe reason why this is a whole family of functions is that you can iterate in various ways and you can get the output in different formats. There are more functions in the family but the general ones are:\n\n-   `lapply()` - loops over elements of a vector/list and returns a list\n\n-   `sapply()` - same as lapply but tries to simplify the result to a vector or matrix\n\n-   `apply()` - used for looping over 2 dimensional structures - it lets you specify if you want to loop over rows or columns\n\n-   `tapply()` - same as apply but lets you split the object you are looping over based on some factor (e.g. imagine you want to calculate the mean value of your dependent variable for each experimental condition).\n\nLets see some of these in action.\n\n## Exercises\n\n1.  Try to code the logic of assigning points to players of a prisoner dilemma with a given matrix:\\\n    ![](images/the-prisoners-dilemma-using-game-theory-to-achieve-the-optimal-solution.jpg){width=\"400\"}\n2.  Create a for loop that will print out the first 50 numbers from the Fibonacci sequence\n3.  Given a dataframe loop over all of its columns and calculate the mean of every numeric column\n",
    "supporting": [
      "04loops_conditionals_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}